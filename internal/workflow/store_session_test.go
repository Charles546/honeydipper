// Copyright 2019 Honey Science Corporation
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, you can obtain one at http://mozilla.org/MPL/2.0/.

// +build !integration

package workflow

import (
	"fmt"
	"reflect"
	"runtime"
	"testing"
	"time"

	"github.com/ghodss/yaml"
	"github.com/golang/mock/gomock"
	"github.com/honeydipper/honeydipper/internal/config"
	"github.com/honeydipper/honeydipper/internal/daemon"
	"github.com/honeydipper/honeydipper/internal/workflow/mock_workflow"
	"github.com/honeydipper/honeydipper/pkg/dipper"
	"github.com/stretchr/testify/assert"
)

var emptyLabels map[string]string

type EqValMatcher struct {
	val         interface{}
	description string
}

func (e *EqValMatcher) Matches(x interface{}) bool {
	return reflect.DeepEqual(x, e.val)
}

func (e *EqValMatcher) String() string {
	return e.description
}

func EqVal(x interface{}) gomock.Matcher {
	return &EqValMatcher{
		val:         x,
		description: fmt.Sprintf("%v", x),
	}
}

func TestStoreSessionOps(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockHelper := mock_workflow.NewMockSessionStoreHelper(ctrl)
	s := NewSessionStore(mockHelper)

	// tear down
	defer delete(dipper.IDMapMetadata, &s.sessions)

	// every test case has following fields
	// - workflow: an workflow object to be executed using StartSession call
	// - msg:      an event message to be passed to initiate the workflow session
	// - ctx:      the ctx generated by the event used for initiating the workflow
	// - asserts:  a func() to be called to assert the success or failure of the test
	//             after an initial message is send out from the session
	//
	// - steps:    during the execution, multiple msgs are passed in and out of the session
	//             each step contains following
	//
	//   * msg:        the message to be passed into the session as using ContinueSession call
	//   * sessionID:  the sessionID used to match message with a session
	//   * ctx:        the exported ctx from the function call
	//   * asserts:    a func() to assert the success of failure of the test after sending
	//                 the message
	//

	testCases := []map[string]interface{}{
		{ // test #1 -- running a noop
			"workflow": &config.Workflow{},
			"msg":      &dipper.Message{},
			"ctx":      map[string]interface{}{},
			"steps":    []map[string]interface{}{},
			"asserts": func() {
				mockHelper.EXPECT().SendMessage(gomock.Any()).Times(0)
			},
		},

		{ // test #2 -- calling a workflow named noop
			"workflow": &config.Workflow{Workflow: "noop"},
			"msg":      &dipper.Message{},
			"ctx":      map[string]interface{}{},
			"steps":    []map[string]interface{}{},
			"asserts": func() {
				mockHelper.EXPECT().SendMessage(gomock.Any()).Times(0)
			},
		},

		{ // test #3 -- calling a driver rawAction
			"workflow": &config.Workflow{CallDriver: "foo.bar"},
			"msg":      &dipper.Message{},
			"ctx":      map[string]interface{}{},
			"asserts": func() {
				mockHelper.EXPECT().SendMessage(EqVal(&dipper.Message{
					Channel: "eventbus",
					Subject: "command",
					Labels: map[string]string{
						"sessionID": "3",
					},
					Payload: map[string]interface{}{
						"ctx": map[string]interface{}{
							"_meta_desc":   "",
							"_meta_name":   "foo.bar",
							"resume_token": "//3",
						},
						"data":  map[string]interface{}{},
						"event": map[string]interface{}{},
						"function": config.Function{
							Driver:    "foo",
							RawAction: "bar",
						},
						"labels": emptyLabels,
					},
				})).Times(1)
			},
			"steps": []map[string]interface{}{
				{
					"sessionID": "3",
					"msg": &dipper.Message{
						Channel: "eventbus",
						Subject: "return",
						Labels: map[string]string{
							"sessionID": "3",
							"status":    "success",
						},
					},
					"ctx": []map[string]interface{}{},
				},
			},
		},

		{ // test #4 -- calling a system function
			"workflow": &config.Workflow{CallFunction: "foo_sys.bar_func"},
			"msg":      &dipper.Message{},
			"ctx":      map[string]interface{}{},
			"asserts": func() {
				mockHelper.EXPECT().SendMessage(EqVal(&dipper.Message{
					Channel: "eventbus",
					Subject: "command",
					Labels: map[string]string{
						"sessionID": "4",
					},
					Payload: map[string]interface{}{
						"ctx": map[string]interface{}{
							"_meta_desc":   "",
							"_meta_name":   "foo_sys.bar_func",
							"resume_token": "//4",
						},
						"data":  map[string]interface{}{},
						"event": map[string]interface{}{},
						"function": config.Function{
							Target: config.Action{
								System:   "foo_sys",
								Function: "bar_func",
							},
						},
						"labels": emptyLabels,
					},
				})).Times(1)
			},
			"steps": []map[string]interface{}{
				{
					"sessionID": "4",
					"msg": &dipper.Message{
						Channel: "eventbus",
						Subject: "return",
						Labels: map[string]string{
							"sessionID": "4",
							"status":    "success",
						},
					},
					"ctx": []map[string]interface{}{},
				},
			},
		},

		{ // test #5 -- run workflow with steps
			"workflow": &config.Workflow{
				Steps: []config.Workflow{
					{
						CallFunction: "foo_sys.bar_func",
					},
					{
						CallDriver: "foo.bar",
					},
					{
						Workflow: "noop",
					},
				},
			},
			"msg": &dipper.Message{},
			"ctx": map[string]interface{}{},
			"asserts": func() {
				mockHelper.EXPECT().SendMessage(EqVal(&dipper.Message{
					Channel: "eventbus",
					Subject: "command",
					Labels: map[string]string{
						"sessionID": "6",
					},
					Payload: map[string]interface{}{
						"ctx": map[string]interface{}{
							"_meta_desc":   "",
							"_meta_name":   "foo_sys.bar_func",
							"resume_token": "//5",
							"step_number":  int32(0),
						},
						"data":  map[string]interface{}{},
						"event": map[string]interface{}{},
						"function": config.Function{
							Target: config.Action{
								System:   "foo_sys",
								Function: "bar_func",
							},
						},
						"labels": emptyLabels,
					},
				})).Times(1)
			},
			"steps": []map[string]interface{}{
				{
					"sessionID": "6",
					"msg": &dipper.Message{
						Channel: "eventbus",
						Subject: "return",
						Labels: map[string]string{
							"sessionID": "6",
							"status":    "success",
						},
					},
					"ctx": []map[string]interface{}{},
					"asserts": func() {
						mockHelper.EXPECT().SendMessage(EqVal(&dipper.Message{
							Channel: "eventbus",
							Subject: "command",
							Labels: map[string]string{
								"sessionID": "7",
							},
							Payload: map[string]interface{}{
								"ctx": map[string]interface{}{
									"_meta_desc":   "",
									"_meta_name":   "foo.bar",
									"resume_token": "//5",
									"step_number":  int32(1),
								},
								"data":  map[string]interface{}{},
								"event": map[string]interface{}{},
								"function": config.Function{
									Driver:    "foo",
									RawAction: "bar",
								},
								"labels": map[string]string{
									"sessionID": "6",
									"status":    "success",
								},
							},
						})).Times(1)
					},
				},
				{
					"sessionID": "7",
					"msg": &dipper.Message{
						Channel: "eventbus",
						Subject: "return",
						Labels: map[string]string{
							"sessionID": "7",
							"status":    "success",
						},
					},
					"ctx": []map[string]interface{}{},
				},
			},
		},

		{ // test #6 -- run workflow with threads
			"workflow": &config.Workflow{
				Threads: []config.Workflow{
					{
						CallFunction: "foo_sys.bar_func",
					},
					{
						CallDriver: "foo.bar",
					},
				},
			},
			"msg": &dipper.Message{},
			"ctx": map[string]interface{}{},
			"asserts": func() {
				mockHelper.EXPECT().SendMessage(gomock.Any()).Times(2)
			},
			"steps": []map[string]interface{}{
				{
					"sessionID": "11",
					"msg": &dipper.Message{
						Channel: "eventbus",
						Subject: "return",
						Labels: map[string]string{
							"sessionID": "11",
							"status":    "success",
						},
					},
					"ctx": []map[string]interface{}{},
				},
				{
					"sessionID": "12",
					"msg": &dipper.Message{
						Channel: "eventbus",
						Subject: "return",
						Labels: map[string]string{
							"sessionID": "12",
							"status":    "success",
						},
					},
					"ctx": []map[string]interface{}{},
				},
			},
		},

		{ // test #7 -- resuming a waiting session
			"workflow": &config.Workflow{
				Steps: []config.Workflow{
					{
						CallFunction: "foo_sys.bar_func",
					},
					{
						Wait: "infinite",
					},
					{
						Workflow: "noop",
					},
				},
			},
			"msg": &dipper.Message{},
			"ctx": map[string]interface{}{},
			"asserts": func() {
				mockHelper.EXPECT().SendMessage(EqVal(&dipper.Message{
					Channel: "eventbus",
					Subject: "command",
					Labels: map[string]string{
						"sessionID": "14",
					},
					Payload: map[string]interface{}{
						"ctx": map[string]interface{}{
							"_meta_desc":   "",
							"_meta_name":   "foo_sys.bar_func",
							"resume_token": "//13",
							"step_number":  int32(0),
						},
						"data":  map[string]interface{}{},
						"event": map[string]interface{}{},
						"function": config.Function{
							Target: config.Action{
								System:   "foo_sys",
								Function: "bar_func",
							},
						},
						"labels": emptyLabels,
					},
				})).Times(1)
			},
			"steps": []map[string]interface{}{
				{
					"sessionID": "14",
					"msg": &dipper.Message{
						Channel: "eventbus",
						Subject: "return",
						Labels: map[string]string{
							"sessionID": "14",
							"status":    "success",
						},
					},
					"ctx": []map[string]interface{}{},
					"asserts": func() {
						mockHelper.EXPECT().SendMessage(gomock.Any()).Times(0)
					},
				},
				{
					"resuming": true,
					"key":      "//13",
					"msg": &dipper.Message{
						Channel: "broadcast",
						Subject: "resume_session",
						Labels:  map[string]string{},
						Payload: map[string]interface{}{
							"key": "//13",
							"labels": map[string]interface{}{
								"status": "success",
							},
						},
					},
					"asserts": func() {
						assert.Equal(t, 2, len(s.sessions), "suspended sessions are still kept in memory")
						assert.Equal(t, 1, len(s.suspendedSessions), "mapping of key to suspended session exists")
					},
				},
			},
		},
	}

	configStr := `
---
systems:
  foo_sys:
    functions:
      bar_func:
        driver: foo1
        rawAction: bar1
workflows:
  noop: {}
  test_steps:
    steps:
      - call_function: foo_sys.bar_func
      - call_driver: foo.bar
      - call_workflow: noop
`

	testDataSet := &config.DataSet{}
	err := yaml.UnmarshalStrict([]byte(configStr), testDataSet, yaml.DisallowUnknownFields)
	assert.Nil(t, err, "test config")
	testConfig := &config.Config{DataSet: testDataSet}

	var step int
	var baseLineNumGoRoutine int
	var testcase map[string]interface{}
	var teststep map[string]interface{}
	var casenum int

	testStartFunc := func() {
		step = -1
		baseLineNumGoRoutine = runtime.NumGoroutine()
		signal := make(chan int, 1)
		go func() {
			s.StartSession(testcase["workflow"].(*config.Workflow), testcase["msg"].(*dipper.Message), testcase["ctx"].(map[string]interface{}))
			daemon.Children.Wait()
			signal <- 1
		}()
		select {
		case <-signal:
		case <-time.After(1 * time.Second):
			panic("timeout")
		}
	}

	testContinueFunc := func() {
		baseLineNumGoRoutine = runtime.NumGoroutine()
		signal := make(chan int, 1)
		go func() {
			s.ContinueSession(teststep["sessionID"].(string), teststep["msg"].(*dipper.Message), teststep["ctx"].([]map[string]interface{}))
			daemon.Children.Wait()
			signal <- 1
		}()
		select {
		case <-signal:
		case <-time.After(1 * time.Second):
			panic("timeout")
		}
	}

	testResumeFunc := func() {
		baseLineNumGoRoutine = runtime.NumGoroutine()
		signal := make(chan int, 1)
		go func() {
			s.ResumeSession(teststep["key"].(string), teststep["msg"].(*dipper.Message))
			daemon.Children.Wait()
			signal <- 1
		}()
		select {
		case <-signal:
		case <-time.After(1 * time.Second):
			panic("timeout")
		}
	}

	for casenum, testcase = range testCases {
		mockHelper = mock_workflow.NewMockSessionStoreHelper(ctrl)
		s.Helper = mockHelper
		mockHelper.EXPECT().GetConfig().AnyTimes().Return(testConfig)
		if assertFunc, ok := testcase["asserts"]; ok {
			assertFunc.(func())()
		}
		if shouldPanic, ok := testcase["panic"]; ok && shouldPanic.(bool) {
			assert.Panics(t, testStartFunc, "expecting panic at starting case %d", casenum)
		} else {
			assert.NotPanics(t, testStartFunc, "expecting not panic at starting case %d", casenum)
		}

		testSteps := testcase["steps"].([]map[string]interface{})
		for step, teststep = range testSteps {
			mockHelper = mock_workflow.NewMockSessionStoreHelper(ctrl)
			s.Helper = mockHelper
			mockHelper.EXPECT().GetConfig().AnyTimes().Return(testConfig)
			if assertFunc, ok := teststep["asserts"]; ok {
				assertFunc.(func())()
			}
			nextFunc := testContinueFunc
			if resuming, ok := teststep["resuming"]; ok && resuming.(bool) {
				nextFunc = testResumeFunc
			}
			if shouldPanic, ok := teststep["panic"]; ok && shouldPanic.(bool) {
				assert.Panics(t, nextFunc, "expecting panic at case %d step %d", casenum, step)
			} else {
				assert.NotPanics(t, nextFunc, "expecting not panic at case %d step %d", casenum, step)
			}
		}
		assert.Equal(t, len(testSteps)-1, step, "expecting number of processed steps at case %d", casenum)
		assert.Equal(t, 0, len(s.sessions), "expecting all session to be completed after case %d", casenum)
	}

	_ = baseLineNumGoRoutine
}
